{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {}
   },
   "source": [
    "# Writing and Using Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Functions are at the heart of most Python packages.  While it is possible to \n",
    "write single use scripts to conduct a variety of simple analytical applications,\n",
    "many more complex applications rely on functions.\n",
    "\n",
    "You can think of a function as a tiny (or potentially large) package of re-usable code, \n",
    "which can be applied multiple times to conduct similar tasks.  Even if you do not \n",
    "plan to write functions yourself, it is useful to know how they work and how to read \n",
    "them, as this will help you be understand how to use functions you find in widely\n",
    "used packages or in code you are working with."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {}
   },
   "source": [
    "## Defining Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {}
   },
   "source": [
    "Functions can be declared with the `def` keyword.  This is followed by\n",
    "the name of the function, and a set of parenthesis that defines the arguments\n",
    "that are inputs to the function.  If there are no arguments, you can put\n",
    "an empty set of parenthesis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "pycharm": {}
   },
   "outputs": [],
   "source": [
    "def greeting():\n",
    "    print(\"Hello, Florida!\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To use a function, you simply use the name of the function (the part that \n",
    "comes immediately after `def`), followed by a set of parenthesis that contains\n",
    "any arguments.  If you are not giving any arguments to the function,\n",
    "you still need the set of parenthesis, even if it is empty."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello, Florida!\n"
     ]
    }
   ],
   "source": [
    "greeting()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Function Arguments\n",
    "\n",
    "Multiple arguments can be defined, and when the function is called\n",
    "the arguments are expected in the same order that they appear in the\n",
    "function definition.  \n",
    "\n",
    "The `return` keyword is used to identify the result.  This value is\n",
    "returned as the output of the function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "42.194883125"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def to_kilometers(miles, feet):\n",
    "    distance = miles + feet/5280\n",
    "    return 1.60934 * distance\n",
    "\n",
    "to_kilometers(26, 1155)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you define arguments like above, then the function must always be\n",
    "called with exactly two arguments as inputs, `miles` and `feet`.\n",
    "\n",
    "Alternatively, you can give optional default values for the \n",
    "arguments. In this case, if the function is called with fewer arguments,\n",
    "the default values are used to fill in the rest."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "pycharm": {}
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "160.934"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def to_kilometers_b(miles, feet=0):\n",
    "    distance = miles + feet/5280\n",
    "    return 1.60934 * distance\n",
    "\n",
    "to_kilometers_b(100)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If there are multiple optional arguments, you can call the function\n",
    "giving specific values for only some of the optional arguments, and\n",
    "letting Python fill in the defaults for the others."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "pycharm": {}
   },
   "outputs": [],
   "source": [
    "def to_kilometers_c(miles, feet=0, yards=0):\n",
    "    distance = miles + feet/5280 + yards/1760\n",
    "    return 1.60934 * distance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "pycharm": {}
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "42.194883125"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "to_kilometers_c(26, yards=385)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "pycharm": {}
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "42.194883125"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "to_kilometers_c(26, feet=1155)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It's also valid to explicitly name arguments that don't have default\n",
    "values, and this allows you to reorder arguments arbitrarily, although\n",
    "it's generally not good coding practice to do so."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "42.194883125"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "to_kilometers_c(feet=1155, miles=26)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you don't specify values for arguments that don't have default values,\n",
    "you'll get an error."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "to_kilometers_c() missing 1 required positional argument: 'miles'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-9-fb71989af844>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mto_kilometers_c\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfeet\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m100\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0myards\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m: to_kilometers_c() missing 1 required positional argument: 'miles'"
     ]
    }
   ],
   "source": [
    "to_kilometers_c(feet=100, yards=0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Arbitrary Arguments\n",
    "\n",
    "Functions that take an arbitrary number of arguments can do so using \"star\" notation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "def county_names(*names):\n",
    "    for name in names:\n",
    "        print(name, \"County\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Pinellas County\n",
      "Leon County\n",
      "Monroe County\n"
     ]
    }
   ],
   "source": [
    "county_names(\"Pinellas\", \"Leon\", \"Monroe\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The argument name preceded by the star is used within the function as a tuple,\n",
    "containing all of the otherwise unnamed positional arguments passed to the \n",
    "function.\n",
    "\n",
    "Other named arguments can appear after the \"star\" argument.  In this case,\n",
    "you cannot set values for these arguments unless you explicitly give\n",
    "the argument name as a keyword argument."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unofficial Names\n",
      "- Alligator Alley\n",
      "- Magic Carpet\n"
     ]
    }
   ],
   "source": [
    "def highway_names(*names, heading=None):\n",
    "    if heading:\n",
    "        print(heading)\n",
    "    for name in names:\n",
    "        print(\"-\",name)\n",
    "        \n",
    "highway_names(\"Alligator Alley\", \"Magic Carpet\", heading=\"Unofficial Names\")            "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Arbitrary keyword arguments can also be accepted using a double-star.\n",
    "In this case, the double-starred argument is used within the function \n",
    "as a dictionary, mapping the given keyword argument names to their values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "I_75 is Alligator Alley\n",
      "US_1 is Magic Carpet\n"
     ]
    }
   ],
   "source": [
    "def more_highway_names(**names):\n",
    "    for key, value in names.items():\n",
    "        print(key,\"is\",value)\n",
    "        \n",
    "more_highway_names(I_75=\"Alligator Alley\", US_1=\"Magic Carpet\")            "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {}
   },
   "source": [
    "## Lambda Functions\n",
    "\n",
    "Alternatively, sometimes simple functions are defined with the `lambda`\n",
    "keyword.  In this case, the arguments are given before the colon, and a single \n",
    "expression is the return value given after the colon:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "pycharm": {}
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<function __main__.<lambda>(km)>"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lambda km: km / 1.60934"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "pycharm": {}
   },
   "source": [
    "Once defined, a function is a function, and it \n",
    "generally doesn't matter if it was defined using `lambda` or `def`.\n",
    "In most python contexts, the `lambda` is only used when \n",
    "the function will not be named, but instead \n",
    "simply used one-time as an argument to some other command."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "pycharm": {}
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[3.106863683249034, 6.213727366498068, 26.218749999999996]"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(map(lambda km: km / 1.60934, [5, 10, 42.194883125]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you find \"lambda\" functions to be confusing or hard to read, you can take solace that you're not\n",
    "alone.  They are generally *not* actually required, and you can nearly always achieve the same \n",
    "effect using a regular named function.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Recursive Functions\n",
    "\n",
    "A function in Python can include code that calls another function -- and it is also\n",
    "allowed for a function to call itself.  This is called a recursive function.  A classic\n",
    "example is a Fibonaci series:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fib(n):\n",
    "    if n == 1:\n",
    "        return [1,]\n",
    "    fib_prior = fib(n-1)\n",
    "    return fib_prior + [sum(fib_prior[-2:])]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[1, 1, 2, 3, 5, 8, 13, 21, 34]"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fib(9)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Python will detect if you enter an infinite loop using recursion, and raise an error (although it takes a bit of time)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "def infinite_recusion(n):\n",
    "    return infinite_recusion(n) + 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "ename": "RecursionError",
     "evalue": "maximum recursion depth exceeded",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mRecursionError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-19-3a5196a18b30>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0minfinite_recusion\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-18-9bf7b7dc30e0>\u001b[0m in \u001b[0;36minfinite_recusion\u001b[0;34m(n)\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0minfinite_recusion\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0minfinite_recusion\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "... last 1 frames repeated, from the frame below ...\n",
      "\u001b[0;32m<ipython-input-18-9bf7b7dc30e0>\u001b[0m in \u001b[0;36minfinite_recusion\u001b[0;34m(n)\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0minfinite_recusion\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0minfinite_recusion\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mRecursionError\u001b[0m: maximum recursion depth exceeded"
     ]
    }
   ],
   "source": [
    "infinite_recusion(2)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {},
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
